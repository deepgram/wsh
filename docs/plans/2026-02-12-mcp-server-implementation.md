# MCP Server Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a Model Context Protocol (MCP) server to wsh, exposing 14 tools, 3 resources, and 9 prompts — embedded in the existing server process via Streamable HTTP, plus a `wsh mcp` stdio bridge subcommand.

**Architecture:** The MCP server is a new `src/mcp/` module that implements the `rmcp::ServerHandler` trait. Tool handlers call the same internal `Session`/`AppState` methods the HTTP handlers use. Streamable HTTP is nested into the existing axum router at `/mcp`. The stdio bridge (`wsh mcp`) auto-spawns a server and bridges MCP JSON-RPC over stdin/stdout.

**Tech Stack:** `rmcp` 0.15 (official Rust MCP SDK), `schemars` 1.0 (JSON Schema for tool params), `tokio-util` 0.7 (cancellation tokens for Streamable HTTP).

**Design doc:** `docs/plans/2026-02-12-mcp-server-design.md`

---

## Task 1: Add Dependencies and Module Skeleton

**Files:**
- Modify: `Cargo.toml`
- Create: `src/mcp/mod.rs`
- Modify: `src/lib.rs`

**Step 1: Add rmcp and supporting dependencies to Cargo.toml**

Add to `[dependencies]`:
```toml
rmcp = { version = "0.15", features = ["server", "macros", "transport-io", "transport-streamable-http-server"] }
schemars = "1.0"
tokio-util = { version = "0.7", features = ["rt"] }
```

Note: `schemars` is needed by rmcp's server feature for tool parameter schema
generation. `tokio-util` provides `CancellationToken` for Streamable HTTP
graceful shutdown.

**Step 2: Create the MCP module skeleton**

Create `src/mcp/mod.rs`:
```rust
pub mod tools;
pub mod resources;
pub mod prompts;

use std::sync::Arc;

use rmcp::{
    ServerHandler, RoleServer,
    handler::server::router::{tool::ToolRouter, prompt::PromptRouter},
    model::*,
    service::RequestContext,
    tool_handler, prompt_handler,
};

use crate::api::AppState;

/// MCP server handler wrapping the wsh AppState.
///
/// Implements the MCP ServerHandler trait, delegating tool calls to the same
/// internal Session methods that the HTTP API uses.
#[derive(Clone)]
pub struct WshMcpServer {
    state: AppState,
    tool_router: ToolRouter<WshMcpServer>,
    prompt_router: PromptRouter<WshMcpServer>,
}

impl WshMcpServer {
    pub fn new(state: AppState) -> Self {
        Self {
            state,
            tool_router: Self::tool_router(),
            prompt_router: Self::prompt_router(),
        }
    }
}
```

This won't compile yet — the `tool_router()` and `prompt_router()` methods are
generated by macros in tasks 2-5.

**Step 3: Add the module to lib.rs**

Add `pub mod mcp;` to `src/lib.rs`.

**Step 4: Create empty submodule files**

Create `src/mcp/tools.rs`, `src/mcp/resources.rs`, `src/mcp/prompts.rs` as
empty files (we'll fill them in subsequent tasks).

**Step 5: Verify it compiles**

Run: `nix develop -c sh -c "cargo check 2>&1"`

This will fail because `WshMcpServer` references `tool_router()` and
`prompt_router()` which don't exist yet. That's expected — we'll fix this in
the next tasks. For now, temporarily comment out the `tool_router` and
`prompt_router` fields and the `Self::tool_router()`/`Self::prompt_router()`
calls, and replace with `todo!()` or similar to verify the dependency wiring is
correct.

Actually, a better approach: leave `src/mcp/mod.rs` as just a module
declaration with empty submodules, and build up `WshMcpServer` incrementally:

```rust
pub mod tools;
pub mod resources;
pub mod prompts;
```

Run: `nix develop -c sh -c "cargo check 2>&1"`
Expected: Compiles successfully (empty modules, new deps resolve).

**Step 6: Commit**

```
feat(mcp): add rmcp dependency and module skeleton
```

---

## Task 2: Implement Session Lifecycle Tools

**Files:**
- Modify: `src/mcp/mod.rs`
- Modify: `src/mcp/tools.rs`

These three tools manage session lifecycle: `wsh_create_session`,
`wsh_list_sessions`, `wsh_manage_session`.

**Step 1: Define tool parameter types in `src/mcp/tools.rs`**

```rust
use serde::{Deserialize, Serialize};
use schemars::JsonSchema;

#[derive(Debug, Deserialize, JsonSchema)]
pub struct CreateSessionParams {
    /// Session name (auto-generated if omitted)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Command to run (default: user's shell)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub command: Option<String>,
    /// Terminal rows (default: 24)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rows: Option<u16>,
    /// Terminal columns (default: 80)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cols: Option<u16>,
    /// Working directory
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwd: Option<String>,
    /// Additional environment variables
    #[serde(skip_serializing_if = "Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ListSessionsParams {
    /// If provided, return details for this session only
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ManageSessionParams {
    /// Target session name
    pub session: String,
    /// Action to perform
    pub action: ManageAction,
    /// New name (required when action is "rename")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_name: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ManageAction {
    Kill,
    Rename,
    Detach,
}
```

**Step 2: Implement the session tools on WshMcpServer**

In `src/mcp/mod.rs`, add the `#[tool_router]` impl block with the three
session tools. Each tool follows the same pattern as the HTTP handlers: look up
the session from `self.state.sessions`, call the appropriate method, return a
`CallToolResult`.

```rust
use rmcp::{tool, tool_router, handler::server::wrapper::Parameters, model::*};
use crate::session::Session;
use crate::pty::SpawnCommand;

#[tool_router]
impl WshMcpServer {
    #[tool(description = "Create a new terminal session with an optional name, command, size, and working directory")]
    async fn wsh_create_session(
        &self,
        Parameters(params): Parameters<tools::CreateSessionParams>,
    ) -> Result<CallToolResult, ErrorData> {
        let rows = params.rows.unwrap_or(24);
        let cols = params.cols.unwrap_or(80);
        let command = SpawnCommand::from(params.command);

        let (session, child_exit_rx) = Session::spawn_with_options(
            params.name.clone().unwrap_or_default(),
            command,
            rows,
            cols,
            params.cwd,
            params.env,
        )
        .map_err(|e| ErrorData::internal_error(format!("session spawn failed: {e}"), None))?;

        let pid = session.pty.child_pid();
        let name = self.state.sessions
            .insert(params.name, session)
            .map_err(|e| ErrorData::internal_error(format!("{e}"), None))?;

        self.state.sessions.monitor_child_exit(name.clone(), child_exit_rx);

        Ok(CallToolResult::success(vec![Content::text(
            serde_json::to_string(&serde_json::json!({
                "session": name,
                "pid": pid,
                "rows": rows,
                "cols": cols,
            }))
            .unwrap(),
        )]))
    }

    #[tool(description = "List all active sessions, or get details for a specific one")]
    async fn wsh_list_sessions(
        &self,
        Parameters(params): Parameters<tools::ListSessionsParams>,
    ) -> Result<CallToolResult, ErrorData> {
        if let Some(name) = params.session {
            let session = self.state.sessions.get(&name)
                .ok_or_else(|| ErrorData::invalid_params(
                    format!("session not found: {name}"), None,
                ))?;
            let size = session.terminal_size.get();
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string(&serde_json::json!({
                    "name": name,
                    "pid": session.pty.child_pid(),
                    "rows": size.0,
                    "cols": size.1,
                    "running": session.pty.is_running(),
                }))
                .unwrap(),
            )]))
        } else {
            let names = self.state.sessions.list();
            let sessions: Vec<_> = names.iter().filter_map(|name| {
                let session = self.state.sessions.get(name)?;
                let size = session.terminal_size.get();
                Some(serde_json::json!({
                    "name": name,
                    "pid": session.pty.child_pid(),
                    "rows": size.0,
                    "cols": size.1,
                    "running": session.pty.is_running(),
                }))
            }).collect();
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string(&sessions).unwrap(),
            )]))
        }
    }

    #[tool(description = "Perform a lifecycle action on a session: kill, rename, or detach all clients")]
    async fn wsh_manage_session(
        &self,
        Parameters(params): Parameters<tools::ManageSessionParams>,
    ) -> Result<CallToolResult, ErrorData> {
        match params.action {
            tools::ManageAction::Kill => {
                self.state.sessions.remove(&params.session)
                    .ok_or_else(|| ErrorData::invalid_params(
                        format!("session not found: {}", params.session), None,
                    ))?;
                Ok(CallToolResult::success(vec![Content::text(
                    r#"{"success": true}"#,
                )]))
            }
            tools::ManageAction::Rename => {
                let new_name = params.new_name
                    .ok_or_else(|| ErrorData::invalid_params(
                        "new_name is required for rename".to_string(), None,
                    ))?;
                self.state.sessions.rename(&params.session, &new_name)
                    .map_err(|e| ErrorData::invalid_params(format!("{e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(
                    r#"{"success": true}"#,
                )]))
            }
            tools::ManageAction::Detach => {
                let session = self.state.sessions.get(&params.session)
                    .ok_or_else(|| ErrorData::invalid_params(
                        format!("session not found: {}", params.session), None,
                    ))?;
                session.detach();
                Ok(CallToolResult::success(vec![Content::text(
                    r#"{"success": true}"#,
                )]))
            }
        }
    }
}
```

Note: The exact field names on `Session`, `Pty`, `TerminalSize` etc. should be
verified against the actual code during implementation. The patterns above
follow what the HTTP handlers do — check `src/api/handlers.rs` for the session
create handler (around line 1881) and session kill handler (around line 1946).

**Step 3: Verify it compiles**

Run: `nix develop -c sh -c "cargo check 2>&1"`

Fix any type mismatches. The `SpawnCommand::from()`, `session.pty.child_pid()`,
`session.pty.is_running()`, and `session.terminal_size.get()` calls should be
verified against the actual types in `src/pty.rs` and `src/terminal.rs`.

**Step 4: Write unit tests for parameter validation**

In `src/mcp/tools.rs`, add tests:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn deserialize_create_session_minimal() {
        let json = r#"{}"#;
        let params: CreateSessionParams = serde_json::from_str(json).unwrap();
        assert!(params.name.is_none());
        assert!(params.command.is_none());
    }

    #[test]
    fn deserialize_create_session_full() {
        let json = r#"{"name":"test","command":"bash","rows":30,"cols":120,"cwd":"/tmp"}"#;
        let params: CreateSessionParams = serde_json::from_str(json).unwrap();
        assert_eq!(params.name.as_deref(), Some("test"));
        assert_eq!(params.rows, Some(30));
    }

    #[test]
    fn deserialize_manage_action_variants() {
        let json = r#"{"session":"test","action":"kill"}"#;
        let params: ManageSessionParams = serde_json::from_str(json).unwrap();
        assert!(matches!(params.action, ManageAction::Kill));

        let json = r#"{"session":"test","action":"rename","new_name":"new"}"#;
        let params: ManageSessionParams = serde_json::from_str(json).unwrap();
        assert!(matches!(params.action, ManageAction::Rename));
    }

    #[test]
    fn deserialize_manage_missing_session_fails() {
        let json = r#"{"action":"kill"}"#;
        let result: Result<ManageSessionParams, _> = serde_json::from_str(json);
        assert!(result.is_err());
    }
}
```

**Step 5: Run tests**

Run: `nix develop -c sh -c "cargo test mcp 2>&1"`
Expected: All parameter deserialization tests pass.

**Step 6: Commit**

```
feat(mcp): implement session lifecycle tools (create, list, manage)
```

---

## Task 3: Implement Terminal I/O Tools

**Files:**
- Modify: `src/mcp/tools.rs`
- Modify: `src/mcp/mod.rs`

Five tools: `wsh_send_input`, `wsh_get_screen`, `wsh_get_scrollback`,
`wsh_await_quiesce`, `wsh_run_command`.

**Step 1: Define parameter types in `src/mcp/tools.rs`**

```rust
#[derive(Debug, Deserialize, JsonSchema)]
pub struct SendInputParams {
    /// Target session name
    pub session: String,
    /// The text or keystrokes to send
    pub input: String,
    /// Input encoding
    #[serde(default = "default_encoding")]
    pub encoding: Encoding,
}

#[derive(Debug, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum Encoding {
    Utf8,
    Base64,
}

fn default_encoding() -> Encoding {
    Encoding::Utf8
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetScreenParams {
    /// Target session name
    pub session: String,
    /// Output format
    #[serde(default = "default_format")]
    pub format: ScreenFormat,
}

#[derive(Debug, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ScreenFormat {
    Styled,
    Plain,
}

fn default_format() -> ScreenFormat {
    ScreenFormat::Styled
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct GetScrollbackParams {
    /// Target session name
    pub session: String,
    /// Starting offset
    #[serde(default)]
    pub offset: usize,
    /// Number of lines to return
    #[serde(default = "default_limit")]
    pub limit: usize,
    /// Output format
    #[serde(default = "default_format")]
    pub format: ScreenFormat,
}

fn default_limit() -> usize {
    100
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct AwaitQuiesceParams {
    /// Target session name
    pub session: String,
    /// Silence threshold in milliseconds
    #[serde(default = "default_timeout_ms")]
    pub timeout_ms: u64,
    /// Overall deadline in milliseconds
    #[serde(default = "default_max_wait_ms")]
    pub max_wait_ms: u64,
}

fn default_timeout_ms() -> u64 {
    2000
}

fn default_max_wait_ms() -> u64 {
    30000
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct RunCommandParams {
    /// Target session name
    pub session: String,
    /// The command or text to send
    pub input: String,
    /// Silence threshold in milliseconds
    #[serde(default = "default_timeout_ms")]
    pub timeout_ms: u64,
    /// Overall deadline in milliseconds
    #[serde(default = "default_max_wait_ms")]
    pub max_wait_ms: u64,
    /// Output format
    #[serde(default = "default_format")]
    pub format: ScreenFormat,
}
```

**Step 2: Implement the tools in the `#[tool_router]` impl block**

Add these to the existing `#[tool_router] impl WshMcpServer` block:

```rust
#[tool(description = "Send keystrokes or text to a session")]
async fn wsh_send_input(
    &self,
    Parameters(params): Parameters<tools::SendInputParams>,
) -> Result<CallToolResult, ErrorData> {
    let session = self.get_session(&params.session)?;
    let data = match params.encoding {
        tools::Encoding::Utf8 => bytes::Bytes::from(params.input.into_bytes()),
        tools::Encoding::Base64 => {
            let decoded = base64::Engine::decode(
                &base64::engine::general_purpose::STANDARD,
                &params.input,
            )
            .map_err(|e| ErrorData::invalid_params(
                format!("invalid base64: {e}"), None,
            ))?;
            bytes::Bytes::from(decoded)
        }
    };
    session.input_tx.send(data).await
        .map_err(|_| ErrorData::internal_error("input send failed".to_string(), None))?;
    session.activity.touch();
    Ok(CallToolResult::success(vec![Content::text(
        r#"{"success": true}"#,
    )]))
}

#[tool(description = "Read the current screen contents of a session")]
async fn wsh_get_screen(
    &self,
    Parameters(params): Parameters<tools::GetScreenParams>,
) -> Result<CallToolResult, ErrorData> {
    let session = self.get_session(&params.session)?;
    let format = params.format.into_parser_format();
    let response = session.parser
        .query(crate::parser::state::Query::Screen { format })
        .await
        .map_err(|e| ErrorData::internal_error(format!("parser error: {e}"), None))?;
    // Serialize the response to JSON
    Ok(CallToolResult::success(vec![Content::text(
        serde_json::to_string(&response).unwrap(),
    )]))
}

#[tool(description = "Read the scrollback buffer history of a session")]
async fn wsh_get_scrollback(
    &self,
    Parameters(params): Parameters<tools::GetScrollbackParams>,
) -> Result<CallToolResult, ErrorData> {
    let session = self.get_session(&params.session)?;
    let format = params.format.into_parser_format();
    let response = session.parser
        .query(crate::parser::state::Query::Scrollback {
            format,
            offset: params.offset,
            limit: params.limit,
        })
        .await
        .map_err(|e| ErrorData::internal_error(format!("parser error: {e}"), None))?;
    Ok(CallToolResult::success(vec![Content::text(
        serde_json::to_string(&response).unwrap(),
    )]))
}

#[tool(description = "Wait for a session's terminal to go idle (no output for the timeout period)")]
async fn wsh_await_quiesce(
    &self,
    Parameters(params): Parameters<tools::AwaitQuiesceParams>,
) -> Result<CallToolResult, ErrorData> {
    let session = self.get_session(&params.session)?;
    let timeout = std::time::Duration::from_millis(params.timeout_ms);
    let deadline = std::time::Duration::from_millis(params.max_wait_ms);

    let generation = tokio::time::timeout(
        deadline,
        session.activity.wait_for_quiescence(timeout, None),
    )
    .await
    .map_err(|_| ErrorData::new(
        rmcp::model::ErrorCode::INTERNAL_ERROR,
        "quiesce timeout exceeded max_wait_ms".to_string(),
        None,
    ))?;

    Ok(CallToolResult::success(vec![Content::text(
        serde_json::to_string(&serde_json::json!({
            "generation": generation,
        }))
        .unwrap(),
    )]))
}

#[tool(description = "Send input, wait for the terminal to go idle, then read the screen. The primary tool for running commands.")]
async fn wsh_run_command(
    &self,
    Parameters(params): Parameters<tools::RunCommandParams>,
) -> Result<CallToolResult, ErrorData> {
    let session = self.get_session(&params.session)?;

    // Send input
    let data = bytes::Bytes::from(params.input.into_bytes());
    session.input_tx.send(data).await
        .map_err(|_| ErrorData::internal_error("input send failed".to_string(), None))?;
    session.activity.touch();

    // Await quiescence
    let timeout = std::time::Duration::from_millis(params.timeout_ms);
    let deadline = std::time::Duration::from_millis(params.max_wait_ms);

    let generation = tokio::time::timeout(
        deadline,
        session.activity.wait_for_quiescence(timeout, None),
    )
    .await;

    // Read screen even if quiesce timed out — return what we have
    let format = params.format.into_parser_format();
    let screen = session.parser
        .query(crate::parser::state::Query::Screen { format })
        .await
        .map_err(|e| ErrorData::internal_error(format!("parser error: {e}"), None))?;

    match generation {
        Ok(gen) => {
            Ok(CallToolResult::success(vec![Content::text(
                serde_json::to_string(&serde_json::json!({
                    "screen": screen,
                    "generation": gen,
                }))
                .unwrap(),
            )]))
        }
        Err(_) => {
            // Quiesce timed out — return screen with isError
            Ok(CallToolResult::error(vec![Content::text(
                serde_json::to_string(&serde_json::json!({
                    "error": "quiesce timeout exceeded max_wait_ms",
                    "screen": screen,
                }))
                .unwrap(),
            )]))
        }
    }
}
```

**Step 3: Add a helper method on WshMcpServer**

```rust
impl WshMcpServer {
    fn get_session(&self, name: &str) -> Result<crate::session::Session, ErrorData> {
        self.state.sessions.get(name)
            .ok_or_else(|| ErrorData::invalid_params(
                format!("session not found: {name}"), None,
            ))
    }
}
```

Also add a conversion helper on `ScreenFormat`:
```rust
impl tools::ScreenFormat {
    pub fn into_parser_format(self) -> crate::parser::state::Format {
        match self {
            Self::Styled => crate::parser::state::Format::Styled,
            Self::Plain => crate::parser::state::Format::Plain,
        }
    }
}
```

**Step 4: Add unit tests for the new param types**

```rust
#[test]
fn deserialize_send_input_defaults() {
    let json = r#"{"session":"main","input":"ls\n"}"#;
    let params: SendInputParams = serde_json::from_str(json).unwrap();
    assert!(matches!(params.encoding, Encoding::Utf8));
}

#[test]
fn deserialize_run_command_defaults() {
    let json = r#"{"session":"main","input":"echo hello\n"}"#;
    let params: RunCommandParams = serde_json::from_str(json).unwrap();
    assert_eq!(params.timeout_ms, 2000);
    assert_eq!(params.max_wait_ms, 30000);
    assert!(matches!(params.format, ScreenFormat::Styled));
}

#[test]
fn deserialize_scrollback_with_pagination() {
    let json = r#"{"session":"main","offset":50,"limit":25,"format":"plain"}"#;
    let params: GetScrollbackParams = serde_json::from_str(json).unwrap();
    assert_eq!(params.offset, 50);
    assert_eq!(params.limit, 25);
    assert!(matches!(params.format, ScreenFormat::Plain));
}
```

**Step 5: Verify it compiles**

Run: `nix develop -c sh -c "cargo check 2>&1"`

**Step 6: Run tests**

Run: `nix develop -c sh -c "cargo test mcp 2>&1"`
Expected: All tests pass.

**Step 7: Commit**

```
feat(mcp): implement terminal I/O tools (send_input, get_screen, scrollback, quiesce, run_command)
```

---

## Task 4: Implement Visual Feedback Tools

**Files:**
- Modify: `src/mcp/tools.rs`
- Modify: `src/mcp/mod.rs`

Four tools: `wsh_overlay`, `wsh_remove_overlay`, `wsh_panel`, `wsh_remove_panel`.

**Step 1: Define parameter types**

Add to `src/mcp/tools.rs`:

```rust
#[derive(Debug, Deserialize, JsonSchema)]
pub struct OverlayParams {
    /// Target session name
    pub session: String,
    /// Overlay ID (omit to create, provide to update)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Column position
    #[serde(skip_serializing_if = "Option::is_none")]
    pub x: Option<u16>,
    /// Row position
    #[serde(skip_serializing_if = "Option::is_none")]
    pub y: Option<u16>,
    /// Z-order
    #[serde(skip_serializing_if = "Option::is_none")]
    pub z: Option<i32>,
    /// Width in columns
    #[serde(skip_serializing_if = "Option::is_none")]
    pub width: Option<u16>,
    /// Height in rows
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u16>,
    /// Background color (e.g. "blue", "#ff0000")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub background: Option<serde_json::Value>,
    /// Styled text spans
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spans: Option<Vec<serde_json::Value>>,
    /// If true, list all overlays instead of create/update
    #[serde(default)]
    pub list: bool,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct RemoveOverlayParams {
    /// Target session name
    pub session: String,
    /// Overlay ID to delete (omit to clear all)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct PanelParams {
    /// Target session name
    pub session: String,
    /// Panel ID (omit to create, provide to update)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Position: "top" or "bottom"
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<String>,
    /// Height in rows
    #[serde(skip_serializing_if = "Option::is_none")]
    pub height: Option<u16>,
    /// Z-order
    #[serde(skip_serializing_if = "Option::is_none")]
    pub z: Option<i32>,
    /// Background color
    #[serde(skip_serializing_if = "Option::is_none")]
    pub background: Option<serde_json::Value>,
    /// Styled text spans
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spans: Option<Vec<serde_json::Value>>,
    /// If true, list all panels instead of create/update
    #[serde(default)]
    pub list: bool,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct RemovePanelParams {
    /// Target session name
    pub session: String,
    /// Panel ID to delete (omit to clear all)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}
```

**Step 2: Implement overlay/panel tools**

Add to the `#[tool_router]` impl block. The overlay and panel tools follow the
upsert pattern and mirror the HTTP handlers in `handlers.rs`.

The implementation should:
- For overlays: use `session.overlays.create()`, `session.overlays.update()`,
  `session.overlays.move_to()`, `session.overlays.list_by_mode()`,
  `session.overlays.delete()`, `session.overlays.clear()`
- For panels: use `session.panels.create()`, `session.panels.patch()`,
  `session.panels.list_by_mode()`, `session.panels.delete()`,
  `session.panels.clear()`
- After mutations, send `session.visual_update_tx.send(VisualUpdate::OverlaysChanged)`
  or `VisualUpdate::PanelsChanged`
- For panel mutations, call `panel::reconfigure_layout()` afterward
- Parse the `spans` and `background` JSON values using the same types the HTTP
  handlers use (check the overlay/panel create handlers for the exact
  deserialization)

The key implementation detail: the `spans` and `background` parameters use
`serde_json::Value` at the MCP parameter level, then deserialize into the
internal types (`OverlaySpan`, `BackgroundStyle`) within the tool handler.
This matches how the HTTP handlers accept JSON bodies.

**Step 3: Add unit tests for overlay/panel param deserialization**

Test the three code paths in `OverlayParams`: create (no id), update (with id),
list (list=true). Same for `PanelParams`.

**Step 4: Verify and run tests**

Run: `nix develop -c sh -c "cargo check 2>&1 && cargo test mcp 2>&1"`

**Step 5: Commit**

```
feat(mcp): implement visual feedback tools (overlay, panel create/update/remove)
```

---

## Task 5: Implement Input & Screen Control Tools

**Files:**
- Modify: `src/mcp/tools.rs`
- Modify: `src/mcp/mod.rs`

Two tools: `wsh_input_mode`, `wsh_screen_mode`.

**Step 1: Define parameter types**

```rust
#[derive(Debug, Deserialize, JsonSchema)]
pub struct InputModeParams {
    /// Target session name
    pub session: String,
    /// Set mode: "capture" or "release" (omit to get current)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<InputModeAction>,
    /// Element ID to focus (overlay or panel)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub focus: Option<String>,
    /// Clear focus
    #[serde(default)]
    pub unfocus: bool,
}

#[derive(Debug, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum InputModeAction {
    Capture,
    Release,
}

#[derive(Debug, Deserialize, JsonSchema)]
pub struct ScreenModeParams {
    /// Target session name
    pub session: String,
    /// Action: "enter_alt" or "exit_alt" (omit to get current)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action: Option<ScreenModeAction>,
}

#[derive(Debug, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ScreenModeAction {
    EnterAlt,
    ExitAlt,
}
```

**Step 2: Implement the tools**

`wsh_input_mode`:
- No mode param: return `{"mode": session.input_mode.get()}`
- mode=capture: `session.input_mode.capture()`
- mode=release: `session.input_mode.release()` + `session.focus.unfocus()`
- focus param: `session.focus.focus(id)` (check focusable first via
  overlays/panels get)
- unfocus param: `session.focus.unfocus()`

`wsh_screen_mode`:
- No action: return `{"mode": "normal"|"alt"}`
- enter_alt: set `*session.screen_mode.write() = ScreenMode::Alt`
- exit_alt: set to Normal, delete alt-mode overlays/panels, reconfigure layout

Follow the patterns in `handlers.rs` for `input_capture`, `input_release`,
`input_focus`, `enter_alt_screen`, `exit_alt_screen`.

**Step 3: Add unit tests**

**Step 4: Verify and run tests**

Run: `nix develop -c sh -c "cargo check 2>&1 && cargo test mcp 2>&1"`

**Step 5: Commit**

```
feat(mcp): implement input and screen mode control tools
```

---

## Task 6: Implement ServerHandler Trait and Wire Up Streamable HTTP

**Files:**
- Modify: `src/mcp/mod.rs`
- Modify: `src/api/mod.rs`

This is where everything comes together: implement the `ServerHandler` trait on
`WshMcpServer` and add the `/mcp` route to the axum router.

**Step 1: Implement ServerHandler**

In `src/mcp/mod.rs`:

```rust
#[tool_handler]
#[prompt_handler]
impl ServerHandler for WshMcpServer {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::V_2024_11_05,
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .enable_resources()
                .enable_prompts()
                .build(),
            server_info: Implementation {
                name: "wsh".to_string(),
                version: env!("CARGO_PKG_VERSION").to_string(),
            },
            instructions: Some(
                "wsh provides terminal session management. Use wsh_run_command for \
                 the common send/wait/read loop. Use wsh_create_session to start \
                 sessions, wsh_list_sessions to discover them, wsh_manage_session \
                 to kill/rename/detach. Visual feedback via wsh_overlay and wsh_panel. \
                 Input capture via wsh_input_mode.".to_string()
            ),
        }
    }

    async fn list_resources(
        &self,
        _request: Option<PaginatedRequestParams>,
        _: RequestContext<RoleServer>,
    ) -> Result<ListResourcesResult, ErrorData> {
        resources::list_resources(&self.state).await
    }

    async fn list_resource_templates(
        &self,
        _request: Option<PaginatedRequestParams>,
        _: RequestContext<RoleServer>,
    ) -> Result<ListResourceTemplatesResult, ErrorData> {
        resources::list_resource_templates().await
    }

    async fn read_resource(
        &self,
        request: ReadResourceRequestParams,
        _: RequestContext<RoleServer>,
    ) -> Result<ReadResourceResult, ErrorData> {
        resources::read_resource(&self.state, request).await
    }
}
```

**Step 2: Add `/mcp` route to the axum router**

In `src/api/mod.rs`, modify the `router()` function to accept the MCP service
and nest it:

```rust
use rmcp::transport::streamable_http_server::{
    StreamableHttpService, StreamableHttpServerConfig,
    session::local::LocalSessionManager,
};

pub fn router(state: AppState, token: Option<String>) -> Router {
    // ... existing code ...

    // Create MCP service
    let mcp_state = state.clone();
    let mcp_service = StreamableHttpService::new(
        move || Ok(crate::mcp::WshMcpServer::new(mcp_state.clone())),
        LocalSessionManager::default().into(),
        StreamableHttpServerConfig::default(),
    );

    Router::new()
        .route("/health", get(health))
        .route("/openapi.yaml", get(openapi_spec))
        .route("/docs", get(docs_index))
        .nest_service("/mcp", mcp_service)
        .merge(protected)
}
```

Note: The MCP service is nested at `/mcp` *outside* the auth middleware,
because MCP has its own protocol-level capability negotiation. If auth is
needed for MCP, it can be added later. Review whether this is correct — it
may need to be inside the auth layer depending on requirements.

**Step 3: Verify it compiles**

Run: `nix develop -c sh -c "cargo check 2>&1"`

**Step 4: Write a basic integration test**

Create `tests/mcp_http.rs`:

```rust
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpListener;
use wsh::api::{self, AppState, ServerConfig};
use wsh::session::SessionRegistry;
use wsh::shutdown::ShutdownCoordinator;

async fn start_test_server() -> SocketAddr {
    let registry = SessionRegistry::new();
    let state = AppState {
        sessions: registry,
        shutdown: ShutdownCoordinator::new(),
        server_config: Arc::new(ServerConfig::new(false)),
    };
    let app = api::router(state, None);
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();
    tokio::spawn(async move {
        axum::serve(listener, app).await.unwrap();
    });
    tokio::time::sleep(Duration::from_millis(50)).await;
    addr
}

#[tokio::test]
async fn test_mcp_health_check() {
    let addr = start_test_server().await;
    let client = reqwest::Client::new();

    // MCP endpoint should respond to POST with JSON-RPC initialize
    let resp = client
        .post(format!("http://{}/mcp", addr))
        .header("Content-Type", "application/json")
        .body(r#"{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1"}}}"#)
        .send()
        .await
        .unwrap();

    assert!(resp.status().is_success());
    let body: serde_json::Value = resp.json().await.unwrap();
    // Should return server info with tools capability
    assert!(body["result"]["capabilities"]["tools"].is_object());
}
```

**Step 5: Run integration test**

Run: `nix develop -c sh -c "cargo test test_mcp_health_check 2>&1"`
Expected: PASS — MCP endpoint accepts initialize and returns capabilities.

**Step 6: Commit**

```
feat(mcp): wire up ServerHandler and Streamable HTTP at /mcp
```

---

## Task 7: Implement Resources

**Files:**
- Modify: `src/mcp/resources.rs`

Three resources: `wsh://sessions`, `wsh://sessions/{name}/screen`,
`wsh://sessions/{name}/scrollback`.

**Step 1: Implement resource handlers**

```rust
use rmcp::model::*;
use crate::api::AppState;

pub async fn list_resources(
    state: &AppState,
) -> Result<ListResourcesResult, ErrorData> {
    let mut resources = vec![
        RawResource::new("wsh://sessions", "Active Sessions".to_string())
            .no_annotation(),
    ];

    // Add per-session resources
    for name in state.sessions.list() {
        resources.push(
            RawResource::new(
                format!("wsh://sessions/{}/screen", name),
                format!("Screen: {}", name),
            )
            .no_annotation(),
        );
        resources.push(
            RawResource::new(
                format!("wsh://sessions/{}/scrollback", name),
                format!("Scrollback: {}", name),
            )
            .no_annotation(),
        );
    }

    Ok(ListResourcesResult {
        resources,
        next_cursor: None,
        meta: None,
    })
}

pub async fn list_resource_templates() -> Result<ListResourceTemplatesResult, ErrorData> {
    Ok(ListResourceTemplatesResult {
        resource_templates: vec![
            ResourceTemplate {
                uri_template: "wsh://sessions/{name}/screen".to_string(),
                name: "Session Screen".to_string(),
                description: Some("Current screen contents of a terminal session".to_string()),
                mime_type: Some("application/json".to_string()),
                annotations: None,
            },
            ResourceTemplate {
                uri_template: "wsh://sessions/{name}/scrollback".to_string(),
                name: "Session Scrollback".to_string(),
                description: Some("Scrollback buffer of a terminal session".to_string()),
                mime_type: Some("application/json".to_string()),
                annotations: None,
            },
        ],
        next_cursor: None,
        meta: None,
    })
}

pub async fn read_resource(
    state: &AppState,
    request: ReadResourceRequestParams,
) -> Result<ReadResourceResult, ErrorData> {
    let uri = request.uri.as_str();

    if uri == "wsh://sessions" {
        let names = state.sessions.list();
        let sessions: Vec<_> = names.iter().filter_map(|name| {
            let session = state.sessions.get(name)?;
            let size = session.terminal_size.get();
            Some(serde_json::json!({
                "name": name,
                "pid": session.pty.child_pid(),
                "rows": size.0,
                "cols": size.1,
                "running": session.pty.is_running(),
            }))
        }).collect();

        return Ok(ReadResourceResult {
            contents: vec![ResourceContents::text(
                serde_json::to_string_pretty(&sessions).unwrap(),
                request.uri,
            )],
        });
    }

    // Parse session-scoped URIs: wsh://sessions/{name}/screen or /scrollback
    let path = uri.strip_prefix("wsh://sessions/")
        .ok_or_else(|| ErrorData::resource_not_found(
            format!("unknown resource: {uri}"), None,
        ))?;

    let (name, resource_type) = path.rsplit_once('/')
        .ok_or_else(|| ErrorData::resource_not_found(
            format!("invalid resource path: {uri}"), None,
        ))?;

    let session = state.sessions.get(name)
        .ok_or_else(|| ErrorData::resource_not_found(
            format!("session not found: {name}"), None,
        ))?;

    match resource_type {
        "screen" => {
            let response = session.parser
                .query(crate::parser::state::Query::Screen {
                    format: crate::parser::state::Format::Styled,
                })
                .await
                .map_err(|e| ErrorData::internal_error(
                    format!("parser error: {e}"), None,
                ))?;
            Ok(ReadResourceResult {
                contents: vec![ResourceContents::text(
                    serde_json::to_string(&response).unwrap(),
                    request.uri,
                )],
            })
        }
        "scrollback" => {
            let response = session.parser
                .query(crate::parser::state::Query::Scrollback {
                    format: crate::parser::state::Format::Styled,
                    offset: 0,
                    limit: 100,
                })
                .await
                .map_err(|e| ErrorData::internal_error(
                    format!("parser error: {e}"), None,
                ))?;
            Ok(ReadResourceResult {
                contents: vec![ResourceContents::text(
                    serde_json::to_string(&response).unwrap(),
                    request.uri,
                )],
            })
        }
        _ => Err(ErrorData::resource_not_found(
            format!("unknown resource type: {resource_type}"), None,
        )),
    }
}
```

**Step 2: Add unit tests for URI parsing**

Test edge cases: valid URIs, unknown URIs, missing session name, etc.

**Step 3: Add integration tests**

Add to `tests/mcp_http.rs`:
- Create a session via MCP tool
- Read `wsh://sessions` resource → session appears
- Read `wsh://sessions/{name}/screen` → screen data returned
- Read unknown resource → error

**Step 4: Run tests**

Run: `nix develop -c sh -c "cargo test mcp 2>&1"`

**Step 5: Commit**

```
feat(mcp): implement resources (sessions, screen, scrollback)
```

---

## Task 8: Implement Prompts

**Files:**
- Modify: `src/mcp/prompts.rs`
- Modify: `src/mcp/mod.rs`
- Create: `skills/wsh/core-mcp/SKILL.md`

**Step 1: Create the MCP-adapted core skill**

Copy `skills/wsh/core/SKILL.md` to `skills/wsh/core-mcp/SKILL.md` and adapt:
- Replace all curl examples with MCP tool name references
- Replace HTTP endpoint paths with tool descriptions
- Keep the same conceptual structure (send/wait/read/decide loop)
- Reference `wsh_run_command`, `wsh_send_input`, `wsh_get_screen`, etc.

**Step 2: Implement prompt loading**

The prompt handler needs to load skill markdown files from the `skills/wsh/`
directory. Use `#[prompt_router]` on `WshMcpServer`:

```rust
// In src/mcp/mod.rs
#[prompt_router]
impl WshMcpServer {
    // Each prompt loads a skill file and returns its content
}
```

However, since prompts need to load files at runtime (and the skill files
are external markdown), the `#[prompt]` macro approach may not be the best
fit. Instead, implement `list_prompts` and `get_prompt` directly on the
`ServerHandler` trait:

```rust
async fn list_prompts(
    &self,
    _request: Option<PaginatedRequestParams>,
    _: RequestContext<RoleServer>,
) -> Result<ListPromptsResult, ErrorData> {
    prompts::list_prompts().await
}

async fn get_prompt(
    &self,
    request: GetPromptRequestParams,
    _: RequestContext<RoleServer>,
) -> Result<GetPromptResult, ErrorData> {
    prompts::get_prompt(&request.name).await
}
```

In `src/mcp/prompts.rs`:

```rust
use rmcp::model::*;

struct SkillDef {
    name: &'static str,
    description: &'static str,
    path: &'static str,
}

const SKILLS: &[SkillDef] = &[
    SkillDef {
        name: "wsh:core",
        description: "API primitives and the send/wait/read/decide loop (MCP-adapted)",
        path: "skills/wsh/core-mcp/SKILL.md",
    },
    SkillDef {
        name: "wsh:drive-process",
        description: "Running CLI commands, handling prompts, command-response workflows",
        path: "skills/wsh/drive-process/SKILL.md",
    },
    SkillDef {
        name: "wsh:tui",
        description: "Operating full-screen terminal applications (vim, htop, lazygit)",
        path: "skills/wsh/tui/SKILL.md",
    },
    SkillDef {
        name: "wsh:multi-session",
        description: "Parallel session orchestration",
        path: "skills/wsh/multi-session/SKILL.md",
    },
    SkillDef {
        name: "wsh:agent-orchestration",
        description: "Driving other AI agents through terminal interfaces",
        path: "skills/wsh/agent-orchestration/SKILL.md",
    },
    SkillDef {
        name: "wsh:monitor",
        description: "Watching and reacting to terminal activity",
        path: "skills/wsh/monitor/SKILL.md",
    },
    SkillDef {
        name: "wsh:visual-feedback",
        description: "Using overlays and panels to communicate with users",
        path: "skills/wsh/visual-feedback/SKILL.md",
    },
    SkillDef {
        name: "wsh:input-capture",
        description: "Capturing keyboard input for dialogs and approvals",
        path: "skills/wsh/input-capture/SKILL.md",
    },
    SkillDef {
        name: "wsh:generative-ui",
        description: "Building dynamic interactive terminal experiences",
        path: "skills/wsh/generative-ui/SKILL.md",
    },
];

pub async fn list_prompts() -> Result<ListPromptsResult, ErrorData> {
    let prompts = SKILLS
        .iter()
        .map(|s| Prompt {
            name: s.name.to_string(),
            description: Some(s.description.to_string()),
            arguments: None,
        })
        .collect();

    Ok(ListPromptsResult {
        prompts,
        next_cursor: None,
        meta: None,
    })
}

pub async fn get_prompt(name: &str) -> Result<GetPromptResult, ErrorData> {
    let skill = SKILLS
        .iter()
        .find(|s| s.name == name)
        .ok_or_else(|| ErrorData::invalid_params(
            format!("unknown prompt: {name}"), None,
        ))?;

    let content = std::fs::read_to_string(skill.path)
        .map_err(|e| ErrorData::internal_error(
            format!("failed to read skill file: {e}"), None,
        ))?;

    Ok(GetPromptResult {
        description: Some(skill.description.to_string()),
        messages: vec![PromptMessage {
            role: PromptMessageRole::User,
            content: PromptMessageContent::text(content),
        }],
    })
}
```

Note: Loading files at runtime means the skill files must be present relative
to the working directory when `wsh` runs. This is fine for development but
may need adjustment for distribution (e.g., embedding with `include_str!` or
using a configurable skill path). For now, relative paths are sufficient.

**Step 3: Remove `#[prompt_handler]` from ServerHandler impl**

Since we're implementing `list_prompts` and `get_prompt` directly on the
`ServerHandler` trait instead of using the prompt router, remove the
`#[prompt_handler]` attribute and `prompt_router` field. Alternatively, keep
the prompt router but implement the prompts as methods. Verify which approach
the rmcp SDK expects — the `#[prompt_handler]` macro may conflict with manual
implementations.

**Step 4: Add unit tests**

- `list_prompts` returns 9 prompts with correct names
- `get_prompt("wsh:core")` returns content
- `get_prompt("nonexistent")` returns error

**Step 5: Add integration test**

Add to `tests/mcp_http.rs`: list prompts via MCP, get a specific prompt.

**Step 6: Run tests**

Run: `nix develop -c sh -c "cargo test mcp 2>&1"`

**Step 7: Commit**

```
feat(mcp): implement prompts (skill loading) and core-mcp skill
```

---

## Task 9: Comprehensive Integration Tests for Streamable HTTP

**Files:**
- Modify: `tests/mcp_http.rs`

This task adds thorough integration tests exercising every tool, resource, and
prompt over the Streamable HTTP transport. The test server setup from Task 6 is
reused.

**Step 1: Helper for MCP JSON-RPC requests**

```rust
async fn mcp_request(
    client: &reqwest::Client,
    addr: SocketAddr,
    method: &str,
    params: serde_json::Value,
) -> serde_json::Value {
    // First initialize if not already done (track state per test)
    let resp = client
        .post(format!("http://{}/mcp", addr))
        .header("Content-Type", "application/json")
        .body(serde_json::to_string(&serde_json::json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": method,
            "params": params,
        })).unwrap())
        .send()
        .await
        .unwrap();
    resp.json().await.unwrap()
}
```

Note: Streamable HTTP MCP requires session management (initialize first, then
subsequent requests use a session token in headers). The exact protocol for
this should be verified against rmcp's `StreamableHttpService` behavior. The
tests may need to:
1. Send `initialize` request, capture session ID from response headers
2. Include session ID in subsequent requests

**Step 2: Session lifecycle tests**

- Create session, verify response has `session`, `pid`, `rows`, `cols`
- List sessions, verify created session appears
- List with specific session name, verify detail response
- Rename session, verify list reflects new name
- Kill session, verify removed from list
- Create duplicate name → error
- Manage nonexistent session → error

**Step 3: Core agent loop test (most critical)**

```rust
#[tokio::test]
async fn test_mcp_run_command() {
    let addr = start_test_server().await;
    // Create session
    // Call wsh_run_command with "echo hello\n"
    // Verify screen contains "hello"
}
```

**Step 4: Terminal I/O tests**

- send_input + await_quiesce + get_screen = same result as run_command
- send_input with base64 encoding
- get_scrollback with pagination
- await_quiesce with timeout → isError

**Step 5: Overlay tests**

- Create → list → update → remove → list empty
- Clear all

**Step 6: Panel tests**

- Same matrix as overlays

**Step 7: Input mode tests**

- Get → capture → get confirms → release → get confirms
- Focus/unfocus

**Step 8: Screen mode tests**

- Get → enter_alt → get confirms → exit_alt → get confirms

**Step 9: Resource tests**

- Read `wsh://sessions` → matches tool output
- Read `wsh://sessions/{name}/screen` → valid data
- Read unknown URI → error

**Step 10: Prompt tests**

- List → 9 prompts
- Get each → non-empty content
- Get unknown → error

**Step 11: Edge case tests**

- Tool call for nonexistent session → error
- Unicode input/output
- Very large screen output

**Step 12: Run all tests**

Run: `nix develop -c sh -c "cargo test mcp 2>&1"`

**Step 13: Commit**

```
test(mcp): comprehensive integration tests for Streamable HTTP
```

---

## Task 10: Implement `wsh mcp` stdio Bridge Subcommand

**Files:**
- Modify: `src/main.rs`

This adds the `wsh mcp` subcommand that bridges MCP JSON-RPC over stdin/stdout
to an auto-spawned or existing wsh server.

**Step 1: Add the Mcp subcommand**

```rust
#[derive(Subcommand, Debug)]
enum Commands {
    // ... existing commands ...

    /// Start an MCP server over stdio (for AI hosts like Claude Desktop)
    Mcp {
        /// Address to bind the HTTP/WebSocket API server (for auto-spawn)
        #[arg(long, default_value = "127.0.0.1:8080")]
        bind: SocketAddr,

        /// Path to the Unix domain socket
        #[arg(long)]
        socket: Option<PathBuf>,

        /// Authentication token
        #[arg(long, env = "WSH_TOKEN")]
        token: Option<String>,
    },
}
```

**Step 2: Implement run_mcp**

The stdio bridge:
1. Tries to connect to an existing server (via HTTP health check or socket)
2. If none found, spawns an ephemeral server daemon (reuse `spawn_server_daemon`)
3. Waits for server to be ready
4. Creates a `WshMcpServer` that talks to the server (either in-process or via
   HTTP client)
5. Serves the MCP handler over stdio transport

The tricky part: the `WshMcpServer` struct needs an `AppState` to work. In the
Streamable HTTP case, it shares the server's `AppState` directly. In the stdio
bridge case, the server is a separate process. Two options:

**Option A: HTTP proxy** — The stdio bridge creates an `AppState` that proxies
calls to the running server via HTTP. This requires a new adapter layer.

**Option B: In-process server** — The stdio bridge starts its own mini server
(without HTTP listener), creates sessions directly. Simpler but means the MCP
sessions are isolated from the main server.

**Option C: Direct AppState** — The stdio bridge starts a full in-process
server (HTTP + MCP), but only exposes MCP over stdio. The HTTP server still
runs for the MCP handler to use `AppState` directly.

Recommended: **Option C** — start a full server in-process with the HTTP
listener bound, then serve MCP over stdio using the same `AppState`. This is
the cleanest approach and means the stdio bridge works identically to the
embedded Streamable HTTP.

```rust
async fn run_mcp(
    bind: SocketAddr,
    socket: Option<PathBuf>,
    token: Option<String>,
) -> Result<(), WshError> {
    use rmcp::{ServiceExt, transport::stdio};

    // Redirect tracing to stderr (stdout is MCP)
    // (tracing is already configured in init_tracing, but ensure it uses stderr)

    // Start server infrastructure in-process
    let sessions = SessionRegistry::new();
    let shutdown = ShutdownCoordinator::new();
    let server_config = std::sync::Arc::new(api::ServerConfig::new(false));
    let state = api::AppState {
        sessions: sessions.clone(),
        shutdown: shutdown.clone(),
        server_config,
    };

    let token = resolve_token(&bind, &token);
    let app = api::router(state.clone(), token);

    // Start HTTP server in background (for any HTTP/WS clients)
    let http_handle = tokio::spawn(async move {
        let listener = tokio::net::TcpListener::bind(bind).await.unwrap();
        axum::serve(listener, app).await.unwrap();
    });

    // Start Unix socket server
    let socket_path = socket.unwrap_or_else(server::default_socket_path);
    let socket_sessions = sessions.clone();
    let socket_handle = tokio::spawn(async move {
        if let Err(e) = server::serve(socket_sessions, &socket_path).await {
            tracing::error!(?e, "Unix socket server error");
        }
    });

    // Serve MCP over stdio
    let mcp = wsh::mcp::WshMcpServer::new(state);
    let service = mcp.serve(stdio()).await.map_err(|e| {
        WshError::Io(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("MCP serve error: {e}"),
        ))
    })?;

    // Wait until the MCP host closes the connection
    service.waiting().await.map_err(|e| {
        WshError::Io(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("MCP wait error: {e}"),
        ))
    })?;

    // Clean up
    http_handle.abort();
    socket_handle.abort();

    Ok(())
}
```

**Step 3: Wire into main()**

```rust
Some(Commands::Mcp { bind, socket, token }) => {
    run_mcp(bind, socket, token).await
}
```

**Step 4: Fix tracing for stdio mode**

MCP uses stdout for protocol messages, so all tracing MUST go to stderr.
The `init_tracing()` function currently uses the default writer (stdout).
For MCP mode, configure tracing to use stderr:

```rust
fn init_tracing_stderr() {
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new(
            std::env::var("RUST_LOG").unwrap_or_else(|_| "wsh=info".into()),
        ))
        .with(tracing_subscriber::fmt::layer().with_writer(std::io::stderr))
        .init();
}
```

Call `init_tracing_stderr()` instead of `init_tracing()` when the Mcp
subcommand is selected.

**Step 5: Verify it compiles**

Run: `nix develop -c sh -c "cargo check 2>&1"`

**Step 6: Manual test**

Test with the MCP inspector:
```bash
nix develop -c sh -c "echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"0.1\"}}}' | cargo run -- mcp 2>/dev/null"
```

Should output a JSON-RPC response with server capabilities.

**Step 7: Commit**

```
feat(mcp): implement `wsh mcp` stdio bridge subcommand
```

---

## Task 11: stdio Bridge Integration Tests

**Files:**
- Create: `tests/mcp_stdio.rs`

**Step 1: Test helper to spawn `wsh mcp` as child process**

```rust
use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader, Write};

fn spawn_mcp() -> std::process::Child {
    Command::new(env!("CARGO_BIN_EXE_wsh"))
        .arg("mcp")
        .arg("--bind")
        .arg("127.0.0.1:0")  // random port
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::null())
        .spawn()
        .expect("failed to spawn wsh mcp")
}
```

Note: `CARGO_BIN_EXE_wsh` is available in integration tests when the binary
is built.

**Step 2: Test initialize over stdio**

Send initialize JSON-RPC, read response, verify capabilities.

**Step 3: Test full tool exercise over stdio**

Create session → run command → read screen → kill session.

**Step 4: Test clean shutdown**

Close stdin → child exits with code 0.

**Step 5: Test malformed input**

Send invalid JSON → error response, process doesn't crash.

**Step 6: Run tests**

Run: `nix develop -c sh -c "cargo test mcp_stdio 2>&1"`

**Step 7: Commit**

```
test(mcp): stdio bridge integration tests
```

---

## Task 12: Compatibility Tests

**Files:**
- Create or modify: `tests/api_unchanged.rs` or add to existing test files

**Step 1: Verify existing HTTP API tests still pass with MCP enabled**

The MCP route (`/mcp`) should not interfere with any existing routes. Run the
full test suite:

Run: `nix develop -c sh -c "cargo test 2>&1"`

All existing tests must pass. If any fail, diagnose and fix.

**Step 2: Add explicit compatibility test**

A test that creates a session via HTTP, interacts via HTTP, and also verifies
the MCP endpoint responds — proving both coexist:

```rust
#[tokio::test]
async fn test_http_and_mcp_coexist() {
    let addr = start_test_server().await;
    let client = reqwest::Client::new();

    // HTTP API: create session
    let resp = client
        .post(format!("http://{}/sessions", addr))
        .json(&serde_json::json!({"name": "test"}))
        .send()
        .await
        .unwrap();
    assert!(resp.status().is_success());

    // HTTP API: list sessions
    let resp = client.get(format!("http://{}/sessions", addr)).send().await.unwrap();
    let sessions: serde_json::Value = resp.json().await.unwrap();
    assert!(sessions.as_array().unwrap().len() > 0);

    // MCP: initialize should also work on same server
    let resp = client
        .post(format!("http://{}/mcp", addr))
        .header("Content-Type", "application/json")
        .body(r#"{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1"}}}"#)
        .send()
        .await
        .unwrap();
    assert!(resp.status().is_success());
}
```

**Step 3: Run full test suite**

Run: `nix develop -c sh -c "cargo test 2>&1"`
Expected: All tests pass, including all existing ones.

**Step 4: Commit**

```
test(mcp): verify HTTP API unchanged with MCP enabled
```

---

## Task 13: Documentation Updates

**Files:**
- Modify: `docs/VISION.md` (update roadmap)
- Modify: `skills/wsh/core/SKILL.md` (mention MCP availability)
- Verify: `docs/plans/2026-02-12-mcp-server-design.md` reflects final state

**Step 1: Update VISION.md roadmap**

Move MCP from "Next" to "Now" in the roadmap section.

**Step 2: Add MCP note to core skill**

Add a brief note to `skills/wsh/core/SKILL.md` mentioning that MCP transport
is also available as an alternative to curl/HTTP.

**Step 3: Verify design doc accuracy**

Review `docs/plans/2026-02-12-mcp-server-design.md` against the actual
implementation. Update any discrepancies.

**Step 4: Commit**

```
docs: update vision roadmap and skills for MCP server
```

---

## Summary

| Task | What | Tools/Tests |
|------|------|-------------|
| 1 | Dependencies + module skeleton | cargo check |
| 2 | Session lifecycle tools (3) | unit tests |
| 3 | Terminal I/O tools (5) | unit tests |
| 4 | Visual feedback tools (4) | unit tests |
| 5 | Input/screen control tools (2) | unit tests |
| 6 | ServerHandler + Streamable HTTP wiring | integration test |
| 7 | Resources (3) | integration tests |
| 8 | Prompts (9 skills) | integration tests |
| 9 | Comprehensive HTTP integration tests | all tools/resources/prompts |
| 10 | `wsh mcp` stdio bridge | manual test |
| 11 | stdio integration tests | integration tests |
| 12 | Compatibility tests | full suite |
| 13 | Documentation updates | — |
